package main

import "os/exec"
import "os"
import "path/filepath"
import "bufio"
import "strings"
import "regexp"
import "fmt"
import "io/ioutil"
import "text/template"
import "bytes"

type pkg struct {
	name string
	cuePath string
	pkg string
	apiVersion string
}

var k8sApi = map[string][]string {
	"admission": {"v1","v1beta1"},
	"admissionregistration": {"v1","v1beta1"},
	"apiserverinternal": {"v1alpha1"},
	"apps": {"v1","v1beta1","v1beta2"},
	"authentication": {"v1","v1beta1"},
	"authorization": {"v1","v1beta1"},
	"autoscaling": {"v1","v2beta1","v2beta2"},
	"batch": {"v1","v1beta1","v2alpha1"},
	"certificates": {"v1","v1beta1"},
	"coordination": {"v1","v1beta1"},
	"core": {"v1"},
	"discovery": {"v1alpha1","v1beta1"},
	"events": {"v1","v1beta1"},
	"extensions": {"v1beta1"},
	"flowcontrol": {"v1alpha1","v1beta1"},
	"imagepolicy": {"v1alpha1"},
	"networking": {"v1","v1beta1"},
	"node": {"v1","v1alpha1","v1beta1"},
	"policy": {"v1beta1"},
	"rbac": {"v1","v1alpha1","v1beta1"},
	"scheduling": {"v1","v1alpha1","v1beta1"},
	"storage": {"v1","v1alpha1","v1beta1"},
}

// these apis don't behave in the same way than normally regarding synax:
var k8sApiManual = map[string]*pkg {
	"corev1": { "corev1", "v1: ", "k8s.io/api/core/v1", "v1"},
}

const importPrefix = "github.com/delyvr/cue/k8s/gen/"

func main() {
	generate := map[string][]pkg{
		"k8s": {},
	}

	for api, versions := range k8sApi {
		for _, version := range versions {
			manualOverride := k8sApiManual[api +version]
			if manualOverride != nil {
				generate["k8s"] = append(generate["k8s"], *manualOverride)
				continue
			}

			generate["k8s"] = append(generate["k8s"], pkg{
				name: api + version,
				cuePath: api + ": " +version+ ": ",
				pkg: "k8s.io/api/"+ api + "/" + version,
				apiVersion: api + "/" + version,
			})
		}

	}

	for name, packages := range generate {
		genDir := "./" + name + "/gen"
		removeDir("./cue.mod/gen")
		removeDir(genDir)
		goGet(packages...)
		cueGet(packages...)
		replaceImports("./cue.mod/gen", importPrefix)
		moveDir("./cue.mod/gen", genDir)

		for _, p := range packages{
			createWrapper(name, p)
		}
	}
}

func createWrapper(name string, p pkg) {
	files := getFilesIn(name + "/gen/" + p.pkg)

	var types []string

	for _, file := range files {
		file, err := os.Open(file)
		if err != nil {
			panic(err)
		}
		previous := ""

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := scanner.Text()

			if line == "\tmetav1.#TypeMeta" {
				typeName := strings.TrimPrefix(previous, "#")
				typeName = strings.TrimSuffix(typeName, ": {")
				if includeType(typeName) {
					types = append(types, typeName)
				}
			}
			previous = line
		}
	}


	header, err := template.New("header").Parse(headerTemplate)
	kind, err := template.New("kind").Parse(k8sTypeTemplate)

	b := new(bytes.Buffer)

	err = header.Execute(b, struct {
		PackageName string
		PackageImport string
	}{
		PackageName: name,
		PackageImport: importPrefix + p.pkg,
	})
	if err != nil {
		panic(err)
	}

	for _, s := range types {
		err = kind.Execute(b, struct {
			Prefix string
			Name string
			ApiVersion string
		}{
			Prefix: p.cuePath,
			Name: s,
			ApiVersion: p.apiVersion,
		})
	}

	err = ioutil.WriteFile("./" + name + "/" + p.name + ".cue", b.Bytes(), os.ModePerm)
	if err != nil {
		panic(err)
	}
}

const headerTemplate = `
// Code generated by generate.go. DO NOT EDIT.
package {{ .PackageName }}

import (
	kube "{{ .PackageImport }}"
)

`

const k8sTypeTemplate = `
{{ .Prefix }} #{{.Name}}: kube.#{{.Name}}
{{ .Prefix }} #{{.Name}}: {
	Kind: "{{.Name}}"
	apiVersion: "{{ .ApiVersion }}"
}
`


func includeType(typ string) bool {
	if strings.HasSuffix(typ, "List") {
		return false
	}

	if strings.HasSuffix(typ, "Options") {
		return false
	}

	if strings.HasSuffix(typ, "Status") {
		return false
	}

	return true
}



func replaceImports(path string, prefix string) {
	files := getFilesIn(path)

	singleLineImport := regexp.MustCompile(".*import (?:[a-zA-z0-9_]* )?\"([a-zA-Z0-9./]+)\"")
	importString := regexp.MustCompile("\"([a-zA-Z0-9./]+)\"")

	for _, filePath := range files {
		file, err := os.Open(filePath)
		if err != nil {
			panic(err)
		}
		out := ""
		var isInImportBlock bool

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := scanner.Text()

			if line == "import (" {
				isInImportBlock = true
			} else if isInImportBlock {
				if line == ")" {
					isInImportBlock = false
				} else {
					match := importString.FindStringSubmatch(line)
					if len(match) > 1 {
						println()
						before := line
						line = strings.ReplaceAll(line, match[1], prefix + match[1])
						fmt.Printf("'%s' => '%s'\n", strings.TrimSpace(before), strings.TrimSpace(line))
					}
				}
			} else {
				match := singleLineImport.FindStringSubmatch(line)
				if len(match) > 1 {
					println()
					before := line
					line = strings.ReplaceAll(line, match[1], prefix + match[1])
					fmt.Printf("'%s' => '%s'\n", strings.TrimSpace(before), strings.TrimSpace(line))
				}
			}

			out += line + "\n"
		}
		_ = file.Close()

		err = ioutil.WriteFile(filePath, []byte(out), os.ModePerm)
		if err != nil {
			panic(err)
		}
	}
}

func removeDir(path string) {
	err := os.RemoveAll(path)
	if err != nil {
		panic(err)
	}
}


func moveDir(from string, to string) {
	execute(true, "mv", from, to)
}

func goGet(packages ...pkg) {
	var pkgNames []string
	for _, p := range packages {
		pkgNames = append(pkgNames, p.pkg)
	}
	execute(true, "go", append([]string{"get", "-v"}, pkgNames...)...)
}

func cueGet(packages ...pkg) {
	var pkgNames []string
	for _, p := range packages {
		pkgNames = append(pkgNames, p.pkg)
	}
	execute(false, "cue", append([]string{"get", "go", "-v"}, pkgNames...)...)
}

func execute(fail bool, name string,  args ...string) {
	cmd := exec.Command(name, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	err := cmd.Run()
	if err != nil && fail {
		panic(err)
	}
}

func getFilesIn(path string) []string{
	var files []string

	_ = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files
}